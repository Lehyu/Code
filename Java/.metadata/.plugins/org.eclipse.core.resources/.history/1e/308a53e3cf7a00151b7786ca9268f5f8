package com.alogrithm;

import java.text.DecimalFormat;

import com.model.Point;

public class DP {
    private static final int INFINITE = 1000;
    private int num;
    private Point[] vertex;
    private double[][] cost;
    private int[][] path;

    public DP(Point[] vertex){
        num = vertex.length;
        this.vertex = vertex;
        cost = new double[num][num];
        path = new int[num][num];

        
    }
    /* cost(i,j) = 0 if i=j;
     * cost(i,j) = min{cost(i,k)+cost(k+1,j)+w(Vi,Vk,Vj)}  if i < j;
     * */
    
    public void compute2(){
    	for(int i = 0; i < num; i++)
    		cost[i][i] = 0;
    	
    	for(int r = 2; r <= num; r++){
            for(int i = 0; i < num - r+1; i++){
                int j = i+r-1;
                if(j == i+1){
                	cost[i][j] = length(vertex[i], vertex[j]);
                	continue;
                }
                path[i][j] = i;
                for(int k = i+1; k < j; k++){
                	double t = cost[i][k] + cost[k+1][j]+weight(vertex[i], vertex[k], vertex[j]);
                	if(t < cost[i][j]){
                		cost[i][j] = t;
                		path[i][j]= k;
                	}
                }       
             
            }
        }
    }
    
    public double weight(Point p1, Point p2, Point p3){
    	double p1p2 = length(p1,p2);
    	double p1p3 = length(p1,p3);
    	double p2p3 = length(p2,p3);
    	return p1p2+p2p3+p1p3;
    }

    /* cost(i,j) = 0  if i=j;
     * cost(i,j) = |ViVj| if j = i+1;
     * cost(i,j) = min{cost(i,k) + cost(k,j)}+|ViVj|  if j > i+1, i < k < j;
     */
    public void compute(){
    	for(int i = 0; i < num; i++){
            for(int j = i; j < num; j++){
                if(i == j){
                    cost[i][j] = 0;
                 //   path[i][j] = i;
                }else{
                	cost[i][j] = INFINITE;
                	//path[i][j] = -1;
                }
            }
        }
        for(int r = 2; r <= num; r++){
            for(int i = 0; i < num - r+1; i++){
                int j = i+r-1;
                double len = length(vertex[i], vertex[j]);
                path[i][j] = i;
                if(j == i+1){
                    cost[i][j] = len;
                   
                }else{
                    for(int k = i+1; k < j; k++){
                        double t = cost[i][k] + cost[k][j]+len;
                        if(t < cost[i][j]){
                            cost[i][j] = t;
                            path[i][j]= k;
                        }
                    }
                }
             
            }
        }
    }
    
    public void getPath(int v, int w){
    	if(v > w){
    		int tmp = v;
    		v = w;
    		w = tmp;
    	}
    	String PATH = ""+w;
    	int k = w;
    	while(k != v ){
    		PATH = "-->"+PATH;
    		k = path[v][k];
    		PATH = k+PATH;    		
    	}
    	
    	for(int i = 0; i < num; i++){
    		for(int j = 0; j < num; j++){
    			System.out.print(path[i][j]+"  ");
    		}
    		System.out.println();
    	}
    	System.out.println(PATH);
    }
    public double getPerimeter(){
    	double perimeter = 0;
    	Point start = vertex[0];
    	for(int i = 1; i < num; i++){
    		Point end = vertex[i];
    		perimeter += length(start, end);
    		start = end;
    	}
    	return perimeter;
    }
    
    public double getLength(int v, int w){
    	if(v >= 0 && w >= 0 && v < num && w < num)
    		return cost[v][w];	
    	else
    		return INFINITE;
    }

    public double length(Point p1, Point p2){
    	double len = Math.sqrt(Math.pow(p1.getX()-p2.getX(), 2) + Math.pow(p1.getY()-p2.getY(), 2));
        return Double.parseDouble(new DecimalFormat("#.000").format(len));
    }
}
